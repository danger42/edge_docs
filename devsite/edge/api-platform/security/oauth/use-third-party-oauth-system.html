  {% extends "_base.html" %} {% block title %}Using Third-Party OAuth Tokens{% endblock %} {% block body %}

  <p>In this topic, we'll discuss how to import externally generated access tokens, refresh tokens,
  or auth codes into the Edge token store. You can use this technique if you would like to
  configure Apigee Edge to validate tokens that are generated outside of Apigee Edge.</p>

<aside class="note">The size of third-party tokens must be {{ limit_oauth_token_size }} or smaller. For
  OAuth usage limits, see <a href="/api-platform/reference/limits">Apigee product limits</a>.</aside>

  <p>In the usual case, Apigee Edge will generate and store an OAuth token, and return it to the
  calling application. The calling app then presents that token back to Apigee Edge when requesting
  service, and Apigee Edge - via the OAuthV2 policy with Operation = VerifyAccessToken - will
  verify that the token is valid. This topic describes how you can configure Apigee Edge to store
  an OAuth token that was generated elsewhere, while keeping the token verification part the same,
  just as if the token was generated by Edge.</p>

  <h2 id="example">Example</h2>

  <p>If you want to see a working example that illustrates the technique
  described in this topic, take a look at the <a href=
  "https://github.com/dzuluaga/apigee-tutorials/tree/master/apiproxies/musicapi-oauth-delegated-authentication">Apigee
  Delegated Token Management sample</a>.</p>

  <h2 id="whatisthis">What is this?</h2>

  <p>Suppose you have an existing authorization system in place, and you would like to use the
  token or code values generated by that system in place of the OAuth2 token or code values that
  Edge generates. You can then make secure API proxy requests with the substituted token or code,
  and Edge will validate them as if they were generated by Edge.</p>

  <h2 id="somebackground">Some Background</h2>

  <p>In the usual case, Apigee Edge generates a token by producing a random string of letters and
  numbers. Apigee Edge associates to that token, other data such as the time the token was issued,
  the expiry, the list of API Products for which the token is valid, and the scope. All of this
  information can be returned in a response automatically generated by the OAuthV2 policy
  configured with Operation = GenerateAccessToken. The response looks like this:</p>
  <pre class="prettyprint">
{
  "issued_at": "1469735625687",
  "application_name": "06947a86-919e-4ca3-ac72-036723b18231",
  "scope": "urn://example.com/read",
  "status": "approved",
  "api_product_list": "[implicit-test]",
  "api_product_list_json": ["implicit-test"],
  "expires_in": "1799", //--in seconds
  "developer.email": "joe@weathersample.com",
  "token_type": "BearerToken",
  "client_id": "U9AC66e9YFyI1yqaXgUF8H6b9wUN1TLk",
  <strong>"access_token": "zBC90HhCGmGlaMBWeZAai2s3za5j",</strong>
  "organization_name": "wwitman",
  "refresh_token_expires_in": "0", //--in seconds
  "refresh_count": "0"
}
</pre>

  <p>The value of the <strong>access_token</strong> attribute is effectively the lookup key for all
  of the other data this metadata. An app could make a request to an API proxy hosted in Edge,
  carrying the bearer token <code>zBC90HhCGmGlaMBWeZAai2s3za5j</code>, and Edge - via the OAuthV2
  policy with Operation = VerifyAccessToken - will look up the token, retrieve all the information,
  and use that information to determine if the token is valid or not, for the requested API Proxy.
  This is called <em>Token validation.</em> All of the above information comprises the token. The
  access_token value is just the way to look up that information.</p>

  <p>On the other hand, by following the steps described here, you can configure Edge to store a
  token so that its <strong>access_token</strong> value is something generated by an external
  service. All of the other metadata might be the same. For example, suppose you have a system
  external to Apigee Edge that generates tokens of the form "TOKEN-&lt;<em>16 random
  numbers</em>&gt;" . In that case, the full token metadata stored by Apigee Edge might be:</p>
  <pre class="prettyprint">
{
  "issued_at": "1469735625687",
  "application_name": "06947a86-919e-4ca3-ac72-036723b18231",
  "scope": "urn://example.com/read",
  "status": "approved",
  "api_product_list": "[implicit-test]",
  "api_product_list_json": ["implicit-test"],
  "expires_in": "1799", //--in seconds
  "developer.email": "joe@weathersample.com",
  "token_type": "BearerToken",
  "client_id": "U9AC66e9YFyI1yqaXgUF8H6b9wUN1TLk",
  <strong>"access_token": "TOKEN-1092837373654221",</strong>
  "organization_name": "wwitman",
  "refresh_token_expires_in": "0", //--in seconds
  "refresh_count": "0"
}
</pre>

  <p>In this case, an app could make a request to an API proxy hosted in Edge, carrying the bearer
  token <code>TOKEN-1092837373654221</code>, and Edge - via the OAuthV2 policy with Operation =
  VerifyAccessToken - will be able to validate it. You can apply a similar import pattern to
  authorization codes and refresh tokens.</p>

  <h2 id="letstalkaboutvalidatingclientcredentials">Let's Talk about Validating Client
  Credentials</h2>

  <p>One pre-requisite to generating a token is validating the requesting client. By default, the
  OAuthV2/GenerateAccessToken policy in Apigee Edge implicitly verifies the client credentials.
  Normally in a request for an OAuthV2 token, the client_id and client_secret are passed in the
  Authorization header, encoded via HTTP Basic Authorization (colon-concatenated, then
  base64-encoded). The OAuthV2/GenerateAccessToken policy in Apigee Edge decodes that header and
  looks up the client_id, and verifies that the passed-in client_secret is valid for that
  client_id. This works if the credentials are known to Apigee Edge - in other words there is a
  Developer App stored within Apigee Edge which contains a credential, which itself contains the
  given client_id and client_secret.</p>

  <p>In the case that the client credentials are not to be validated by Apigee Edge, you must
  design your API Proxy, before it generates a token, to explicitly validate the client via some
  other means. Often this is via a <a href=
  "/api-platform/reference/policies/service-callout-policy.html">ServiceCallout policy</a> that
  connects to a remote endpoint in your network.</p>

  <p>One way or the other, either implicitly or explicitly, you need to ensure that the API Proxy
  that generates tokens, first validates the client credentials. Keep in mind that validating the
  client is independent of generating the access token. You can configure Apigee Edge to do both,
  or to do one or the other, or neither.</p>

  <p>If you want the OAuthV2/GenerateAccessToken policy in Apigee Edge to validate the client
  credentials against the Edge store, set the <code>&lt;ExternalAuthorization&gt;</code> element to
  <code>false</code> inside the policy configuration, or omit it entirely. If you want to use an
  external authorization service to explicitly validate the client credentials, set
  <code>&lt;ExternalAuthorization&gt;</code> to <code>true</code>.</p>

  <p>Though Apigee Edge may not validate the client credentials, it is still necessary for the
  client_id to be known and managed by Apigee Edge. Every access_token in Apigee Edge, whether
  generated by Apigee Edge or generated by an external system and then imported into Apigee Edge,
  must be associated to a client application - indicated by the client_id. So even in the case
  where the OAuthV2/GenerateAccessToken policy in Apigee Edge will not validate that the client_id
  and client_secret match, the policy will validate that the client_id is valid, present, and not
  revoked. So as a pre-requisite setup step, you may have to import client_id's via the Edge
  administrative API.</p>

  <h2 id="policyflowforthirdpartyoauthonapigee">Policy Flow for third-party OAuth on Apigee</h2>

  <p>To use tokens from third-party OAuth systems in Apigee Edge, the flow for generating access
  tokens should follow one of the following patterns.</p>

  <h3 id="policyflowforthirdpartyoauthonapigee-externalvalidationofclientcredentials">External
  Validation of Client Credentials</h3>

  <ol>
    <li><a href="/api-platform/reference/policies/service-callout-policy.html">ServiceCallout</a>
    to Verify the inbound client credentials, and acquire an external token.</li>

    <li><a href=
    "/api-platform/reference/policies/extract-variables-policy.html">ExtractVariables</a> or a
    <a href="/api-platform/reference/policies/javascript-policy.html">JavaScript step</a> to
    extract the externally-generated token from the response.</li>

    <li><a href="/api-platform/reference/policies/assign-message-policy.html">AssignMessage</a> to
    set the special well-known-variable called <code>oauth_external_authorization_status</code>.
    The value must be true to indicate the client credentials are valid.</li>

    <li><a href=
    "/api-platform/reference/policies/oauthv2-policy.html">OAuthV2</a>/GenerateAccessToken with the
    <code>&lt;ExternalAuthorization&gt;</code> element set to <code>true</code>, and at least one
    of <code>&lt;ExternalAccessToken&gt;</code>, <code>&lt;ExternalRefreshToken&gt;</code>, or
    <code>&lt;ExternalAuthorizationCode&gt;</code>.</li>
  </ol>

  <h3 id="policyflowforthirdpartyoauthonapigee-internalvalidationofclientcredentials">Internal
  Validation of Client Credentials</h3>

  <ul>
    <li><a href="/api-platform/reference/policies/service-callout-policy.html">ServiceCallout</a>
    to acquire an external token.</li>

    <li><a href=
    "/api-platform/reference/policies/extract-variables-policy.html">ExtractVariables</a> or a
    <a href="/api-platform/reference/policies/javascript-policy.html">JavaScript step</a> to
    extract the externally-generated token from the response.</li>

    <li><a href=
    "/api-platform/reference/policies/oauthv2-policy.html">OAuthV2</a>/GenerateAccessToken with the
    <code>&lt;ExternalAuthorization&gt;</code> element set to <code>false</code>, and at least one
    of <code>&lt;ExternalAccessToken&gt;</code>, <code>&lt;ExternalRefreshToken&gt;</code>, or
    <code>&lt;ExternalAuthorizationCode&gt;</code>.</li>
  </ul>

  <h2 id="notesontheflowandpolicyconfiguration">Notes on the flow and policy configuration</h2>

<aside class="note">The size of third-party tokens must be {{ limit_oauth_token_size }} or smaller.
For OAuth usage limits, see <a href="/api-platform/reference/limits">Apigee product limits</a>.</aside>

  <ul>
    <li>
      <p>In the case that you wish to use an external system to validate client credentials, it is
      up to you to develop a policy flow that does what is necessary. Normally you would use a
      ServiceCallout policy to send the externally recognized credentials to the external
      authentication service. The external authentication service would typically return a response
      and, if the credentials are valid, also an access token.</p>
    </li>

    <li>
      <p>After the ServiceCallout, the API proxy needs to parse the response to extract the
      validity status, as well as the externally generated access_token and possibly the
      refresh_token.</p>
    </li>

    <li>
      <p>In the OAuthV2/GenerateAccessToken policy, set the <code>&lt;StoreToken&gt;</code> element
      to <code>true</code>, and set the <code>&lt;ExternalAuthorization&gt;</code> element to
      <code>true</code> or <code>false</code> as appropriate.</p>

      <p>When the OAuthV2/GenerateAccessToken policy executes, it reads the variable
      <code>oauth_external_authorization_status</code>. If the variable is set and the value is
      true, then Apigee Edge does not attempt to validate the client credentials. If the variable
      is not set or the value is not true, then Apigee Edge will attempt to validate client
      credentials.</p>
    </li>

    <li>
      <p>There are three elements for the OAuthV2 policy that allow you to specify the external
      data to import: <code>&lt;ExternalAccessToken&gt;</code>,
      <code>&lt;ExternalRefreshToken&gt;</code>,
      and <code>&lt;ExternalAuthorizationCode&gt;</code>. Each of these elements accepts a
      <strong>flow variable</strong>. The Edge policy will read that variable to find the
      externally-generated access token, refresh token, or authorization code. It's up to you to
      implement policies and logic to place the external tokens or codes in the appropriate
      variables.</p>

      <p>For example, the following configuration in the OAuthV2 policy tells Edge to look for the
      token in a context variable named <code>external_token</code>.</p>
      <pre class="prettyprint">
&lt;ExternalAccessToken&gt;external_token&lt;/ExternalAccessToken&gt;
</pre>

      <p>You would need to also have a previous step thart sets that variable.</p>
    </li>

    <li>
      <p>Regarding setting the <code>oauth_external_authorization_status</code> variable, a common
      technique for setting this variable is to use an <a href=
      "/api-platform/reference/policies/assign-message-policy.html">AssignMessage policy</a> with
      the AssignVariable element, like this:</p>
      <pre class="prettyprint">
&lt;AssignMessage name="AssignMessage-SetVariable"&gt;
    &lt;DisplayName&gt;Assign Message - Set Variable&lt;/DisplayName&gt;
    &lt;AssignVariable&gt;
        &lt;Name&gt;oauth_external_authorization_status&lt;/Name&gt;
        &lt;Value&gt;true&lt;/Value&gt;
    &lt;/AssignVariable&gt;
    &lt;IgnoreUnresolvedVariables&gt;true&lt;/IgnoreUnresolvedVariables&gt;
&lt;/AssignMessage&gt;
</pre>

      <p>Remember, this policy must fall before the OAuthV2 policy with Operation =
      GenerateAccessToken.</p>
    </li>
  </ul>

  <h2 id="exampleoauthv2policy">Example OAuthV2 policy</h2>

  <p>The following OAuthV2 policy generates an Apigee Edge access token given that Edge finds a
  token value in the flow variable <code>external_access_token</code>.</p>
  <pre class="prettyprint">
&lt;OAuthV2 name="OAuth-v20-Store-External-Token"&gt;
    &lt;DisplayName&gt;OAuth v2.0 1&lt;/DisplayName&gt;
    &lt;Attributes/&gt;
    &lt;ExternalAccessToken&gt;external_access_token&lt;/ExternalAccessToken&gt;
    &lt;ExternalAuthorization&gt;true&lt;/ExternalAuthorization&gt;
    &lt;Operation&gt;GenerateAccessToken&lt;/Operation&gt;
    &lt;GenerateResponse enabled="true"&gt;
        &lt;Format&gt;FORM_PARAM&lt;/Format&gt;
    &lt;/GenerateResponse&gt;
    &lt;ReuseRefreshToken&gt;false&lt;/ReuseRefreshToken&gt;
    &lt;StoreToken&gt;true&lt;/StoreToken&gt;
    &lt;SupportedGrantTypes&gt;
        &lt;GrantType&gt;client_credentials&lt;/GrantType&gt;
    &lt;/SupportedGrantTypes&gt;
    &lt;Tokens/&gt;
&lt;/OAuthV2&gt;
</pre>

  <aside class="note">Normally, with the client
  credentials grant type, you need to provide a Basic Authentication header with the encoded Client
  ID and Client Secret. However, in this case, you do <strong>not</strong> need to provide that
  header. The policy still expects the <code>client_id</code> to be present in the request, and the
  policy will validate it. Edge expects the <code>client_id</code> to be sent as part
  of the request form data, e.g., in <code>request.formparam.client_id</code>.</aside>

  <p>In theory, you could apply this pattern with any third-party OAuth2 authorization
  service.</p>{% endblock %}
