  {% extends "_base.html" %} {% block title %}Key points of API proxy development{% endblock %} {% block body %}

  <p>This topic lists some basic characteristics of API proxies, along with links to more
  information.</p>

  <h2 id=
  "apisareentrypointsforoneapplicationtousethecapabilitiesofanotheryouimplementapiproxiestocreateapis">
  APIs are entry points for one application to use the capabilities of another. You implement API
  proxies to create APIs</h2>

  <p>In Apigee Edge, you implement API proxies by configuring API proxy logic as a sequence of
  steps that execute in response to a request from client code. You expose an API proxy to clients
  by defining endpoints that include a URL with resource paths, an HTTP verb, body requirements,
  and so on.</p>

  <p>Though it's called an API proxy, from the client code's perspective, <em>it's the
  API</em>.</p>

  <p>For an overview of API proxies, see <a href=
  "/api-platform/fundamentals/understanding-apis-and-api-proxies.html">Understanding APIs and API
  proxies</a>.</p>

  <h2 id="youarrangethesequenceofapiproxylogicusingflows">You arrange the sequence of API proxy
  logic using flows</h2>

  <p>In any application, data flows through the application guided by condition logic. In Apigee
  Edge, the path of processing is made up of flows. A flow is a sequence of stages (or "steps")
  that makeu up an API proxy's processing path. Flows are how Apigee Edge provides places for you
  to apply logic and behavior at specific places from client to backend resource, then back to
  client.</p>

  <p>For more on flows, see <a href="/api-platform/fundamentals/what-are-flows.html">Controlling
  how a proxy executes with flows</a></p>

  <h2 id="youaccessstatedatathroughflowvariablescreatedbyapiproxies">You access state data through
  flow variables created by API proxies</h2>

  <p>An API proxy has access to variables that represent execution state. You can access these
  variables from the XML that configures your API proxies and policies. You can also access them
  when you're extending an API proxy with a procedural language, such as Java, JavaScript, or
  Python.</p>

  <p>These variables are held by Apigee Edge. Some exist by default, usually because they're common
  to what API proxies do (such as because they're part of an HTTP request). You can also create
  your own variables to satisfy a logic requirement.</p>

  <p>For more about variables, see <a href=
  "/api-platform/fundamentals/introduction-flow-variables.html">Managing proxy state with flow
  variables</a>.</p>

  <h2 id="youcanhaveapiproxiesexecuteconditionally">You can have API proxies execute
  conditionally</h2>

  <p>Just as in most programming languages, in API proxies you can have code execute conditionally.
  Conditions are often based on API proxy state, which you can access through flow variables. For
  example, you can have a condition that checks for the user agent, then processes the request
  accordingly.</p>

  <p>For more on conditional execution, see <a href=
  "/api-platform/fundamentals/flow-variables-and-conditions.html">Flow variables and
  conditions</a>.</p>

  <h2 id="youimplementmostlogicinanapiproxyusingpolicies">You implement most logic in an API proxy
  using policies</h2>

  <p>Most of the logic you add to an API proxy is packaged as policies. A policy is an Apigee Edge
  component that encapsulates logic for a functional area, such as security or traffic management.
  You configure a policy with XML that sets properties for the underlying logic. You arrange
  policies in a sequence of "steps" within a flow, so that your API proxy executes the logic in the
  best order for your proxy's goals.</p>

  <p>For more about policies, see <a href=
  "/api-platform/develop/policy-attachment-and-enforcement.html">What's a policy?</a>.</p>

  <h2 id="youcanincludereusablesetsoffunctionality">You can include reusable sets of
  functionality</h2>

  <p>When your API proxy includes logic that will be used from multiple places in your code -- such
  as other API proxies -- you can collect that logic for calls from multiple places. For example,
  you can group security logic in a shared flow that other API proxies call, reducing duplication
  across API proxies.</p>

  <p>For more on shared flows, see <a href="/api-platform/fundamentals/shared-flows.html">Reusable
  shared flows</a>. For more on API proxy chaining, see <a href=
  "/api-platform/fundamentals/connecting-proxies-other-proxies.html">Chaining API proxies
  together</a>.</p>

  <h2 id="youcandebugaproxywiththetracetool">You can debug a proxy with the Trace tool</h2>

  <p>Apigee Edge includes a Trace tool you can use to examine your API proxy's execution flow when
  debugging and testing. The tool visually presents each API proxy step that executes for a
  request. As in a debugger, at each step you can view the list of variable values that make up API
  proxy state.</p>

  <p>For more about debugging with Trace, see <a href=
  "/api-platform/debug/using-trace-tool-0.html">Using the Trace tool</a>.</p>

  <h2 id="youhandleapiproxyerrorsasfaults">You handle API proxy errors as faults</h2>

  <p>By configuring a fault handler, you can customize the error returned to an API client. Fault
  handlers give you control over error messages whether the error originates from your own code or
  from an included component (such as a policy).</p>

  <p>For more, see <a href="/api-platform/fundamentals/fault-handling.html">Handling
  faults</a>.</p>{% endblock %}
