  {% extends "_base.html" %} {% block title %}API proxy configuration reference{% endblock %} {% block body %}

  <p>As a developer working with the Apigee Edge, your primary development activities involve
  configuring API proxies that function as proxies for APIs or backend services. This document is a
  reference of all configuration elements available to you when building API proxies. </p>

  <p>If you are learning how to build API proxies, it is recommended that you begin with the topic
   <a href="/api-platform/fundamentals/build-simple-api-proxy.html">Build a simple API
  proxy</a>.</p>

  <h2 id="apiproxystructure">API proxy structure</h2>

  <p>An API proxy consists of the following configuration:</p>

  <table>
    <tbody>
      <tr>
        <td><strong>Base Configuration</strong></td>

        <td>Primary configuration settings for an API proxy. See <a href="#baseconfig">Base
        Configuration.</a></td>
      </tr>

      <tr>
        <td><strong>ProxyEndpoint Configuration</strong></td>

        <td>Settings for the inbound HTTP connection (from requesting apps to Apigee Edge), request
        and response flows, and policy attachments. See <a href=
        "#proxyendpoint">ProxyEndpoint</a>.</td>
      </tr>

      <tr>
        <td><strong>TargetEndpoint Configuration</strong></td>

        <td>Settings for the outbound HTTP connection (from Apigee Edge to the backend service),
        request and response flows, and policy attachments. See <a href=
        "#targetendpoint">TargetEndpoint.</a></td>
      </tr>

      <tr>
        <td><strong>Flows</strong></td>

        <td>ProxyEndpoint and TargetEndpoint request and response pipelines to which polices can be
        attached. See <a href="#flows">Flows</a>.</td>
      </tr>

      <tr>
        <td><strong>Policies</strong></td>

        <td>XML-formatted configuration files that conform to the Apigee Edge policy schemas. See
        <a href="#policies">Policies</a>.</td>
      </tr>

      <tr>
        <td><strong>Resources</strong></td>

        <td>Scripts, JAR files, and XSLT files referenced by policies to execute custom logic. See
        <a href="#resources">Resources</a>.</td>
      </tr>
    </tbody>
  </table>

  <h3 id="apiproxystructure-apiproxydirectorystructureandcontents">API proxy directory structure
  and contents</h3>

  <p>The components in the table above are defined by configuration files in the following
  directory structure:</p>

  <p><img alt="" src="/api-platform/images/apiproxy2.png"></p>

  <h2 id="configurationfilesanddirectorystructureofanapiproxy">Configuration files and directory
  structure of an API proxy</h2>

  <p>This section explain the configuration files and directory structure of an API proxy.</p>

  <ul>
    <li><a href="#baseconfig">Base Configuration</a></li>

    <li><a href="#proxyendpoint">ProxyEndpoint</a></li>

    <li>
      <a href="#targetendpoint">TargetEndpoint</a>

      <ul>
        <li><a href="#advancedtargetendpoint">TLS/SSL TargetEndpoint Configuration</a></li>
      </ul>
    </li>

    <li><a href="#policies">Policies</a></li>

    <li><a href="#flows">Flows</a></li>

    <li><a href="#resources">Resources</a></li>
  </ul>

  <h2 id="baseconfiguration"><a name="baseconfig" id="baseconfig"></a>Base Configuration</h2>

  <h3 id="baseconfiguration-apiproxyweatherapixml"><code>/apiproxy/weatherapi.xml</code></h3>

  <p>The base configuration for an API proxy, which defines the name of the API proxy. The name
  must be unique within an organization.</p>

  <p>Sample configuration:</p>
  <pre class="prettyprint">
&lt;APIProxy name="weatherapi"&gt;
&lt;/APIProxy&gt;
</pre>

  <h3 id="baseconfiguration-baseconfigurationelements">Base Configuration Elements</h3>

  <table>
    <thead>
      <tr>
        <th>Name</th>

        <th>Description</th>

        <th>Default</th>

        <th>Required?</th>
      </tr>
    </thead>

    <tbody>
      <tr>
        <td><b><code>APIProxy</code></b></td>

        <td colspan="3"> </td>
      </tr>

      <tr>
        <td><code>name</code></td>

        <td>The name of the API proxy, which must be unique within an organization. The characters
        you are allowed to use in the name are restricted to the following:
        <code>A-Za-z0-9_-</code></td>

        <td>N/A</td>

        <td>Yes</td>
      </tr>

      <tr>
        <td><code>revision</code></td>

        <td>The revision number of the API proxy configuration. You do not need to explicitly set
        the revision number, since Apigee Edge automatically tracks the current revision of the API
        proxy.</td>

        <td>N/A</td>

        <td>No</td>
      </tr>

      <tr>
        <td><code>ConfigurationVersion</code></td>

        <td>The version of the API proxy configuration schema to which this API proxy conforms. The
        only supported value currently is majorVersion 4 and minorVersion 0. This setting may be
        used in the future to enable evolution of the API proxy format.</td>

        <td>4.0</td>

        <td>No</td>
      </tr>

      <tr>
        <td><code>Description</code></td>

        <td>A textual description of the API proxy. If provided, the description will display in
        the Edge management UI.</td>

        <td>N/A</td>

        <td>No</td>
      </tr>

      <tr>
        <td><code>DisplayName</code></td>

        <td>A user-friendly name that may be different from the <code>name</code> attribute of the
        API proxy configuration.</td>

        <td>N/A</td>

        <td>No</td>
      </tr>

      <tr>
        <td><code>Policies</code></td>

        <td>A list of policies in the <code>/policies</code> directory of this API proxy. You will
        normally only see this element when the API proxy was created using the Edge management UI.
        This is simply a 'manifest' setting, designed to provide visibility into the contents of
        the API proxy.</td>

        <td>N/A</td>

        <td>No</td>
      </tr>

      <tr>
        <td><code>ProxyEndpoints</code></td>

        <td>A list of ProxyEndpoints in the <code>/proxies</code> directory of this API proxy. You
        will normally only see this element when the API proxy was created using the Edge
        management UI. This is simply a 'manifest' setting, designed to provide visibility into the
        contents of the API proxy.</td>

        <td>N/A</td>

        <td>No</td>
      </tr>

      <tr>
        <td><code>Resources</code></td>

        <td>A list of resources (JavaScript, Python, Java, XSLT) in the <code>/resources</code>
        directory of this API proxy. You will normally only see this element when the API proxy was
        created using the Edge management UI. This is simply a 'manifest' setting, designed to
        provide visibility into the contents of the API proxy.</td>

        <td>N/A</td>

        <td>No</td>
      </tr>

      <tr>
        <td><code>Spec</code></td>

        <td>Identifies the OpenAPI Specification that is associated with the API proxy. The value
        is set to a URL or to a path in the specification store.<br>
        <br>
        <strong>Note</strong>: The specification store is available in the New Edge experience
        only. For more information about the specification store, see <a href=
        "https://docs-new.apigee.com/manage-share-specs" target="_blank">Managing and sharing
        specifications</a>.</td>

        <td>N/A</td>

        <td>No</td>
      </tr>

      <tr>
        <td><code>TargetServers</code></td>

        <td>A list of TargetServers referenced in any TargetEndpoints of this API proxy. You will
        normally only see this element when the API proxy was created using the Edge management UI.
        This is simply a 'manifest' setting, designed to provide visibility into the contents of
        the API proxy.</td>

        <td>N/A</td>

        <td>No</td>
      </tr>

      <tr>
        <td><code>TargetEndpoints</code></td>

        <td>A list of TargetEndpoints in the <code>/targets</code> directory of this API proxy. You
        will normally only see this element when the API proxy was created using the Edge
        management UI. This is simply a 'manifest' setting, designed to provide visibility into the
        contents of the API proxy.</td>

        <td>N/A</td>

        <td>No</td>
      </tr>
    </tbody>
  </table>

  <h2 id="proxyendpoint"><a name="proxyendpoint" id="proxyendpoint"></a>ProxyEndpoint</h2>

  <p><img src="/api-platform/images/proxy_endpoints.png" width="650"></p>

  <h3 id="proxyendpoint-apiproxyproxiesdefaultxml"><code>/apiproxy/proxies/default.xml</code></h3>

  <p>The ProxyEndpoint configuration defines the inbound (client-facing) interface for an API
  proxy. When you configure a ProxyEndpoint, you are setting up a network configuration that
  defines how client applications ('apps') should invoke the proxied API.</p>

  <p>The following sample ProxyEndpoint configuration would be stored under
  <code>/apiproxy/proxies</code>:</p>
  <pre class="prettyprint">
&lt;ProxyEndpoint name="default"&gt;
  &lt;PreFlow/&gt;
  &lt;Flows/&gt;
  &lt;PostFlow/&gt;
  &lt;HTTPProxyConnection&gt;
    &lt;BasePath&gt;/weather&lt;/BasePath&gt;
    &lt;VirtualHost&gt;default&lt;/VirtualHost&gt;
  &lt;/HTTPProxyConnection&gt;
  &lt;FaultRules/&gt;
  &lt;DefaultFaultRule/&gt;
  &lt;RouteRule name="default"&gt;
    &lt;TargetEndpoint&gt;default&lt;/TargetEndpoint&gt;
  &lt;/RouteRule&gt;
&lt;/ProxyEndpoint&gt;
</pre>

  <p>The required configuration elements in a basic ProxyEndpoint are:</p>

  <h3 id="proxyendpoint-proxyendpointconfigurationelements">ProxyEndpoint Configuration
  Elements</h3>

  <table>
    <thead>
      <tr>
        <th>Name</th>

        <th>Description</th>

        <th>Default</th>

        <th>Required?</th>
      </tr>
    </thead>

    <tbody>
      <tr>
        <td><b><code>ProxyEndpoint</code></b></td>

        <td colspan="3"> </td>
      </tr>

      <tr>
        <td><code>name</code></td>

        <td>The name of the ProxyEndpoint. Must be unique within the API proxy configuration, when
        (in rare cases) multiple ProxyEndpoints are defined. The characters you are allowed to use
        in the name are restricted to the following: <code>A-Z0-9._\-$ %</code>.</td>

        <td>N/A</td>

        <td>Yes</td>
      </tr>

      <tr>
        <td><strong><code>PreFlow</code></strong></td>

        <td>Defines the policies in the PreFlow flow of a request or response.</td>

        <td>N/A</td>

        <td>Yes</td>
      </tr>

      <tr>
        <td><strong><code>Flows</code></strong></td>

        <td>
          <div>
            Defines the policies in the conditional flows of a request or response.
          </div>
        </td>

        <td>N/A</td>

        <td>Yes</td>
      </tr>

      <tr>
        <td><strong><code>PostFlow</code></strong></td>

        <td>
          <div>
            Defines the policies in the PostFlow flow of a request or response.
          </div>
        </td>

        <td>N/A</td>

        <td>Yes</td>
      </tr>

      <tr>
        <td><b><code>HTTPProxyConnection</code></b></td>

        <td colspan="3">Defines the network address and URI path associated with the API proxy</td>
      </tr>

      <tr>
        <td><code>BasePath</code></td>

        <td>
          <p>A required string that uniquely identifies the URI path used by Apigee Edge to route
          incoming messages to the proper API proxy.</p>

          <p>The BasePath is a URI fragment (for example <code>/weather</code>) appended to the
          base URL of an API proxy (for example, <code>http://apifactory-test.apigee.net</code>).
          BasePath must be unique within an environment. Uniqueness is validated when an API proxy
          is generated or imported.</p>

          <p><strong>Using a wildcard in base paths</strong></p>

          <p>You can use one or more "*" wildcards in API proxy base paths. For example, a base
          path of <code>/team/*/members</code> allows clients to call
          <code>https://[host]/team/<strong>blue</strong>/members</code> and
          <code>https://[host]/team/<strong>green</strong>/members</code> without you needing to
          create new API proxies to support new teams. Note that /**/ is not supported.</p>

          <p><strong>Important:</strong> Apigee does NOT support using a wildcard "*" as the first
          element of a base path. For example, this is NOT supported: <code>/*/search</code>.
          Starting the base path with a "*" can lead to unexpected errors because of the way Edge
          identifies valid paths.</p>
        </td>

        <td>/</td>

        <td>Yes</td>
      </tr>

      <tr>
        <td><code>VirtualHost</code></td>

        <td>
          <p>Associates an API proxy with specific base URLs for an environment. A VirtualHost is a
          named configuration that defines one or more URLs for an environment.</p>

          <p>The named VirtualHosts defined for a ProxyEndpoint determine the domains and ports on
          which an API proxy is exposed, and, by extension, the URL that apps use to invoke an API
          proxy.</p>

          <p>By default, two named VirtualHosts are defined for an environment:
          <code>default</code> and <code>secure</code>. An organization may also define custom
          domains. To ensure that an API proxy is available only over HTTPs, for example, set the
          VirtualHost in the HTTPProxyConnection to <code>secure</code>.</p>
        </td>

        <td>default</td>

        <td>Yes</td>
      </tr>

      <tr>
        <td><code>Properties</code></td>

        <td>A set of optional HTTP configuration settings can be defined as properties of a
        ProxyEndpoint. See <a href=
        "/api-platform/reference/policies/endpoint-properties-reference.html">Endpoint properties
        reference</a>.</td>

        <td>N/A</td>

        <td>No</td>
      </tr>

      <tr>
        <td><strong><span style=
        "font-family:courier new,courier,monospace;">FaultRules</span></strong></td>

        <td>
          <div>
            Defines how the ProxyEndpoint reacts to an error. A fault rule specifies two
            items:
          </div>

          <ul>
            <li>A Condition that specifies the fault to be handled based on the pre-defined
            category, subcategory, or name of the fault</li>

            <li>One or more policies that define the behavior of the fault rule for the
            corresponding Condition</li>
          </ul>

          <p>See <a href="/api-platform/fundamentals/fault-handling.html">Handling faults</a>.</p>
        </td>

        <td>N/A</td>

        <td>No</td>
      </tr>

      <tr>
        <td><strong><code>DefaultFaultRule</code></strong></td>

        <td>
          <p>Handles any errors (system, transport, messaging or policy) that are not explicitly
          handled by another fault rule.</p>

          <p>See <a href="/api-platform/fundamentals/fault-handling.html">Handling faults</a>.</p>
        </td>

        <td>N/A</td>

        <td>No</td>
      </tr>

      <tr>
        <td><b><code>RouteRule</code></b></td>

        <td colspan="3">Defines the destination of inbound request messages after processing by the
        ProxyEndpoint request pipeline. Usually, the RouteRule points to a named TargetEndpoint
        configuration, but it can also point directly to a URL.</td>
      </tr>

      <tr>
        <td><code>Name</code></td>

        <td>Required attribute, which provides a name for the RouteRule. The characters you are
        allowed to use in the name are restricted to the following: <code>A-Z0-9._\-$ %</code>. For
        example, <code>Cat2 %_</code> is a legal name.</td>

        <td>N/A</td>

        <td>Yes</td>
      </tr>

      <tr>
        <td><code>Condition</code></td>

        <td>An optional conditional statement used for dynamic routing at runtime. Conditional
        RouteRules are useful, for example, to enable content-based routing to support backend
        versioning.</td>

        <td>N/A</td>

        <td>No</td>
      </tr>

      <tr>
        <td><code>TargetEndpoint</code></td>

        <td>
          <p>An optional string that identifies a named TargetEndpoint configuration. A named
          TargetEndpoint is any TargetEndpoint defined in the same API proxy under
          the<code>/targets</code> directory).</p>

          <p>By naming a TargetEndpoint, you indicate where request messages should be forwarded
          after processing by the ProxyEndpoint request pipeline. Note that this is an optional
          setting.</p>

          <p>A ProxyEndpoint may call a URL directly. For example, a JavaScript or Java resource,
          functioning in the role of an HTTP client, may perform the basic duty of a
          TargetEndpoint, which is to forward requests to a backend service.</p>
        </td>

        <td>N/A</td>

        <td>No</td>
      </tr>

      <tr>
        <td>URL</td>

        <td>An optional string that defines an outbound network address called by the
        ProxyEndpoint, bypassing any TargetEndpoint configurations that might be stored under
        <code>/targets</code></td>

        <td>N/A</td>

        <td>No</td>
      </tr>
    </tbody>
  </table>

  <h3 id="proxyendpoint-howtoconfigurerouterules">How to configure RouteRules</h3>

  <p>A named TargetEndpoint refers to a configuration file under <code>/apiproxy/targets</code> to
  which the RouteRule forwards a request after processing by the ProxyEndpoint.</p>

  <p>For example, the following RouteRule refers to the configuration
  <code>/apiproxy/targets/myTarget.xml</code>:</p>

  <div id="well">
    <pre class="prettyprint">
&lt;RouteRule name="default"&gt;
  &lt;TargetEndpoint&gt;myTarget&lt;/TargetEndpoint&gt;
&lt;/RouteRule&gt;
</pre>
  </div>

  <h3 id="proxyendpoint-directurlinvocation">Direct URL Invocation</h3>

  <p>A ProxyEndpoint can also directly invoke a backend service. Direct URL invocation bypasses any
  named TargetEndpoints configuration under <code>/apiproxy/targets</code>). For this reason,
  TargetEndpoint is an optional API proxy configuration, although, in practice, direct invocation
  from the ProxyEndpoint is not recommended.</p>

  <p>For example, the following RouteRule makes an HTTP call to
  <code>http://api.mycompany.com/v2</code>.</p>
  <pre class="prettyprint">
&lt;RouteRule name="default"&gt;
  &lt;URL&gt;http://api.mycompany.com/v2&lt;/URL&gt; 
&lt;/RouteRule&gt;
</pre>

  <h3 id="proxyendpoint-conditionalroutes">Conditional Routes</h3>

  <p>RouteRules can be chained to support dynamic routing at runtime. Inbound requests can be
  routed to named TargetEndpoint configurations, directly to URLs, or to a combination of the two,
  based on HTTP headers, message content, query parameters, or contextual information such time of
  day, locale, etc.</p>

  <p>Conditional RouteRules work like other conditional statements on Apigee Edge. See <a href=
  "/api-platform/reference/conditions-reference.html">Conditions reference</a> and <a href=
  "/api-platform/reference/variables-reference.html">Variables reference</a>.</p>

  <p>For example, the following RouteRule combination first evaluates the inbound request to verify
  the value of an HTTP header. If the HTTP header <code>routeTo</code> has the value
  <code>TargetEndpoint1</code>, then the request is forwarded to the TargetEndpoint named
  <code>TargetEndpoint1</code>. If not, then the inbound request is forwarded to
  <code>http://api.mycompany.com/v2</code>.</p>
  <pre class="prettyprint">
&lt;RouteRule name="MyRoute"&gt;
  &lt;Condition&gt;request.header.routeTo = "TargetEndpoint1"&lt;/Condition&gt;
  &lt;TargetEndpoint&gt;TargetEndpoint1&lt;/TargetEndpoint&gt;
&lt;/RouteRule&gt;
&lt;RouteRule name="default"&gt;
  &lt;URL&gt;http://api.mycompany.com/v2&lt;/URL&gt;
&lt;/RouteRule&gt;
</pre>

  <aside class="note">
    <b>Note:</b> <strong>More dynamic routing</strong>

    <p><a href=
    "https://community.apigee.com/questions/1326/specifying-proxy-endpoint.html">http://community.apigee.com/questions/1326/specifying-proxy-endpoint.html</a><br>

    shows dynamic routing to different world regions based on variables extracted from the request
    URI.</p>
  </aside>

  <h3 id="proxyendpoint-nullroutes">Null Routes</h3>

  <p>A null RouteRule can be defined to support scenarios in which the request message does not
  need to be forwarded to the TargetEndpoint. This is useful when the ProxyEndpoint performs all of
  the necessary processing, for example by using JavaScript to call an external service or
  retrieving data from a lookup to the API Services' key/value store.</p>

  <p>For example, the following defines a null Route:</p>
  <pre class="prettyprint">
&lt;RouteRule name="GoNowhere"/&gt;
</pre>

  <p>Conditional null Routes can be useful. In the following example, a null Route is configured to
  execute when an HTTP header <code>request.header.X-DoNothing</code> have a value other than
  <code>null</code>.</p>
  <pre class="prettyprint">
&lt;RouteRule name="DoNothingOnDemand"&gt;
  &lt;Condition&gt;request.header.X-DoNothing != null&lt;/Condition&gt;
&lt;/RouteRule&gt;
</pre>

  <p>Remember, RouteRules can be chained, so a conditional null Route would typically be one
  component of a set of RouteRules designed to support conditional routing.</p>

  <p>A practical use of a conditional null Route would be in support of caching. By using the value
  of the variable that is set by the Cache policy, you can configure an API proxy to execute the
  null Route when an entry is served from the cache.</p>
  <pre class="prettyprint">
&lt;RouteRule name="DoNothingUnlessTheCacheIsStale"&gt;
  &lt;Condition&gt;lookupcache.LookupCache-1.cachehit is true&lt;/Condition&gt;
&lt;/RouteRule&gt;
</pre>

  <h2 id="targetendpoint"><a name="targetendpoint" id="targetendpoint"></a>TargetEndpoint</h2>

  <p><img src="/api-platform/images/proxy_endpoints.png" width="650"></p>

  <p>A TargetEndpoint is the outbound equivalent of a ProxyEndpoint. A TargetEndpoint functions as
  client to a backend service or API -- it sends requests and receives responses.</p>

  <p>An API proxy needn't have any TargetEndpoints. ProxyEndpoints can be configured to call URLs
  directly. An API proxy with no TargetEndpoints usually contains a ProxyEndpoint that either
  directly calls a backend service, or that is configured to call a service using Java or
  JavaScript.</p>

  <h3 id="targetendpoint-targetendpointconfiguration">TargetEndpoint Configuration</h3>

  <h3 id="targetendpoint-targetsdefaultxml"><code>/targets/default.xml</code></h3>

  <p>The TargetEndpoint defines the outbound connection from Apigee Edge to another service or
  resource.</p>

  <p>Here's a sample TargetEndpoint configuration:</p>
  <pre class="prettyprint">
&lt;TargetEndpoint name="default"&gt;
  &lt;PreFlow/&gt;
  &lt;Flows/&gt;
  &lt;PostFlow/&gt;
  &lt;HTTPTargetConnection&gt;
    &lt;URL&gt;http://mocktarget.apigee.net&lt;/URL&gt;
    &lt;SSLInfo/&gt;
  &lt;/HTTPTargetConnection&gt;
  &lt;FaultRules/&gt;
  &lt;DefaultFaultRule/&gt;
  &lt;ScriptTarget/&gt;
  &lt;LocalTargetConnection/&gt;
&lt;/TargetEndpoint&gt;
</pre>

  <h3 id="targetendpoint-targetendpointconfigurationelements">TargetEndpoint Configuration
  Elements</h3>

  <p>A TargetEndpoint can call a target in one of the following ways:</p>

  <ul>
    <li>HTTPTargetConnection for HTTP(S) calls</li>

    <li>LocalTargetConnection for local proxy-to-proxy <a href=
    "/api-platform/fundamentals/connecting-proxies-other-proxies.html" target=
    "_blank">chaining</a></li>

    <li>ScriptTarget for calls to an Edge-hosted <a href=
    "/api-platform/nodejs/overview-nodejs-apigee-edge.html" target="_blank">Node.js script</a></li>
  </ul>

  <p>Configure only one of these in a TargetEndpoint.</p>

  <table>
    <thead>
      <tr>
        <th>Name</th>

        <th>Description</th>

        <th>Default</th>

        <th>Required?</th>
      </tr>
    </thead>

    <tbody>
      <tr>
        <td><b><code>TargetEndpoint</code></b></td>

        <td colspan="3"> </td>
      </tr>

      <tr>
        <td><code>name</code></td>

        <td>The name of the TargetEndpoint, which must be unique within the API proxy
        configuration. The name of the TargetEndPoint is used in the ProxyEndpoint RouteRule to
        direct requests for outbound processing. The characters you are allowed to use in the name
        are restricted to the following: <code>A-Z0-9._\-$ %</code>. </td>

        <td>N/A</td>

        <td>Yes</td>
      </tr>

      <tr>
        <td><strong><code>PreFlow</code></strong></td>

        <td>Defines the policies in the PreFlow flow of a request or response.</td>

        <td>N/A</td>

        <td>Yes</td>
      </tr>

      <tr>
        <td><strong><code>Flows</code></strong></td>

        <td>
          <div>
            Defines the policies in the conditional flows of a request or response.
          </div>
        </td>

        <td>N/A</td>

        <td>Yes</td>
      </tr>

      <tr>
        <td><strong><code>PostFlow</code></strong></td>

        <td>
          <div>
            Defines the policies in the PostFlow flow of a request or response.
          </div>
        </td>

        <td>N/A</td>

        <td>Yes</td>
      </tr>

      <tr>
        <td><b><code>HTTPTargetConnection</code></b></td>

        <td colspan="3">
          <p>With its child elements, specifies a backend resource reach via HTTP.</p>

          <p>If you use HTTPTargetConnection, don't configure other types of target connections
          (ScriptTarget or LocalTargetConnection).</p>
          <aside class="note">The <code>&lt;LocalTargetConnection&gt;</code> elements support the dynamic string substitution feature called
  <a href="/api-platform/reference/message-template-intro.html">message templating</a>.</aside>
        </td>
      </tr>

      <tr>
        <td><code>URL</code></td>

        <td>Defines the network address of the backend service to which the TargetEndpoint forwards
        request messages.</td>

        <td>N/A</td>

        <td>No</td>
      </tr>

      <tr>
        <td><code>LoadBalancer</code></td>

        <td>
          <p>Defines one or more named TargetServer configurations. Named TargetServer
          configurations can be used for load balancing defining 2 or more endpoint configuration
          connections.</p>

          <p>You can also use TargetServers to decouple API proxy configurations from concrete
          backend service endpoints URLs.</p>

          <p>See <a href="/api-platform/deploy/load-balancing-across-backend-servers.html">Load
          balancing across backend servers</a>.</p>
        </td>

        <td>N/A</td>

        <td>No</td>
      </tr>

      <tr>
        <td><code>Properties</code></td>

        <td>A set of optional HTTP configuration settings can be defined as properties of a
        TargetEndpoint. See <a href=
        "/api-platform/reference/policies/endpoint-properties-reference.html">Endpoint properties
        reference</a>.</td>

        <td>N/A</td>

        <td>No</td>
      </tr>

      <tr>
        <td><code>SSLInfo</code></td>

        <td>Optionally define TLS/SSL settings on a TargetEndpoint to control the TLS/SSL
        connection between the API proxy and the target service. See <a href=
        "#advancedtargetendpoint">TLS/SSL TargetEndpoint Configuration</a>.
        <aside class="note">The <code>&lt;SSLInfo&gt;</code> element supports the dynamic string substitution feature called
  <a href="/api-platform/reference/message-template-intro.html">message templating</a>.</aside>

        </td>

        <td>N/A</td>

        <td>No</td>
      </tr>

      <tr>
        <td><b><code>LocalTargetConnection</code></b></td>

        <td colspan="3">
          With its child elements, specifies a resource to be reached locally, bypassing network
          characteristics such as load balancing and message processors.

          <p>To specify the target resource, include either the APIProxy child element (with the
          ProxyEndpoint element) or the Path child element.</p>

          <p>For more information, see <a href=
          "/api-platform/fundamentals/connecting-proxies-other-proxies.html">Chaining API proxies
          together</a>.</p>

          <p>If you use LocalTargetConnection, don't configure other types of target connections
          (HTTPTargetConnection or ScriptTarget).</p>
        </td>
      </tr>

      <tr>
        <td><code>APIProxy</code></td>

        <td>Specifies the name of an API proxy to use as a target for requests. The target proxy
        must be in the same organization and environment as the proxy sending requests. This is an
        alternative to using the Path element.</td>

        <td>N/A</td>

        <td>No</td>
      </tr>

      <tr>
        <td><code>ProxyEndpoint</code></td>

        <td>Used with APIProxy to specify the name of the target proxy's ProxyEndpoint.</td>

        <td>N/A</td>

        <td>No</td>
      </tr>

      <tr>
        <td><code>Path</code></td>

        <td>Specifies the endpoint path of an API proxy to use as a target for requests. The target
        proxy must be in the same organization and environment as the proxy sending requests. This
        is an alternative to using APIProxy.</td>

        <td>N/A</td>

        <td>No</td>
      </tr>

      <tr>
        <td><strong><span style=
        "font-family:courier new,courier,monospace;">FaultRules</span></strong></td>

        <td>
          <div>
            Defines how the TargetEndpoint reacts to an error. A fault rule specifies two
            items:
          </div>

          <ul>
            <li>A Condition that specifies the fault to be handled based on the pre-defined
            category, subcategory, or name of the fault</li>

            <li>One or more policies that define the behavior of the fault rule for the
            corresponding Condition</li>
          </ul>

          <p>See <a href="/api-platform/fundamentals/fault-handling.html">Handling faults</a>.</p>
        </td>

        <td>N/A</td>

        <td>No</td>
      </tr>

      <tr>
        <td><strong><code>DefaultFaultRule</code></strong></td>

        <td>
          <p>Handles any errors (system, transport, messaging or policy) that are not explicitly
          handled by another FaultRule.</p>

          <p>See <a href="/api-platform/fundamentals/fault-handling.html">Handling faults</a>.</p>
        </td>

        <td>N/A</td>

        <td>No</td>
      </tr>

      <tr>
        <td><b><code>ScriptTarget</code></b></td>

        <td colspan="3"> </td>
      </tr>

      <tr>
        <td><code>ResourceURL</code></td>

        <td>
          <p>Defines the resource type (node) and the name of the main Node.js script that
          implements TargetEndpoint functionality.</p>

          <p><span style=
          "font-family:courier new,courier,monospace;">&lt;ResourceURL&gt;node://server.js&lt;/ResourceURL&gt;</span></p>

          <p>The script needs to be included with your API proxy's resource files. See <a href=
          "/api-platform/nodejs/adding-nodejs-existing-api-proxy.html">Adding Node.js to an
          existing API proxy</a>.</p>

          <p>If you use ScriptTarget, don't configure other types of target connections
          (HTTPTargetConnection or LocalTargetConnection).</p>
        </td>

        <td>N/A</td>

        <td>Yes</td>
      </tr>

      <tr>
        <td><code>EnvironmentVariable</code></td>

        <td>
          <p>Optionally pass environment variables to the main Node.js script. </p>

          <p>See <a href=
          "/api-platform/nodejs/understanding-edge-support-nodejs-modules.html">Understanding Edge
          support for Node.js modules</a>.</p>
        </td>

        <td>N/A</td>

        <td>No</td>
      </tr>

      <tr>
        <td><code>Arguments</code></td>

        <td>
          <p>Optionally pass arguments to the main Node.js script.</p>

          <p>See <a href=
          "/api-platform/nodejs/understanding-edge-support-nodejs-modules.html">Understanding Edge
          support for Node.js modules</a>.</p>
        </td>

        <td>N/A</td>

        <td>No</td>
      </tr>
    </tbody>
  </table>

  <h2 id="tlsssltargetendpointconfiguration"><a name="advancedtargetendpoint" id=
  "advancedtargetendpoint"></a>TLS/SSL TargetEndpoint Configuration</h2>

  <p>TargetEndpoints often need to manage HTTPS connections with heterogenous backend
  infrastructure. For this reason, a number of TLS/SSL configuration settings are supported.</p>

  <aside class="note"><b>Note:</b> Because Edge originally supported SSL, you will see some
  instances in the Edge UI and in the Edge XML that use the term "SSL". For example, the menu entry
  in the Edge UI that you use to view certs is called <strong>SSL Certificates</strong>. The
  XML tag that you use to configure a virtual host to use TLS is named <span style=
  "font-family:courier new,courier,monospace;">&lt;SSLInfo&gt;</span>. </aside>

  <h3 id="tlsssltargetendpointconfiguration-tlsssltargetendpointconfigurationelements">TLS/SSL
  TargetEndpoint Configuration Elements</h3>

  <table>
    <thead>
      <tr>
        <th>Name</th>

        <th>Description</th>

        <th>Default</th>

        <th>Required?</th>
      </tr>
    </thead>

    <tbody>
      <tr>
        <td><b><code>SSLInfo</code></b></td>

        <td colspan="3"> </td>
      </tr>

      <tr>
        <td><code>Enabled</code></td>

        <td>Indicates whether TLS/SSL is enabled for the endpoint.
          The default value is <code>true</code> if <code>&lt;URL&gt;</code> specifies the HTTPS protocol,
          and <code>false</code> if <code>&lt;URL&gt;</code> specifies HTTP.</td>

        <td>true if <code>&lt;URL&gt;</code> specifies HTTPS</td>

        <td>No</td>
      </tr>

      <tr>
        <td><code>TrustStore</code></td>

        <td>A keystore containing trusted server certificates.</td>

        <td>N/A</td>

        <td>No</td>
      </tr>

      <tr>
        <td><code>ClientAuthEnabled</code></td>

        <td>A setting that turns on outbound client authentication (2-way TLS/SSL)</td>

        <td>false</td>

        <td>No</td>
      </tr>

      <tr>
        <td><code>KeyStore</code></td>

        <td>A keystore containing private keys used for outbound client authentication</td>

        <td>N/A</td>

        <td>Yes (if ClientAuthEnabled is true)</td>
      </tr>

      <tr>
        <td><code>KeyAlias</code></td>

        <td>The key alias of the private key used for outbound client authentication</td>

        <td>N/A</td>

        <td>Yes (if ClientAuthEnabled is true)</td>
      </tr>

      <tr>
        <td><code>Ciphers</code></td>

        <td>
          <p>Supported ciphers for outbound TLS/SSL. If no ciphers are specified, then all ciphers
          available for the JVM will be permitted.</p>

          <p>To restrict ciphers, add the following elements listing the supported ciphers:</p>
          <pre class="prettyprint">
&lt;Ciphers&gt;
 &lt;Cipher&gt;TLS_RSA_WITH_3DES_EDE_CBC_SHA&lt;/Cipher&gt;    
 &lt;Cipher&gt;TLS_RSA_WITH_DES_CBC_SHA&lt;/Cipher&gt;
&lt;/Ciphers&gt;
</pre>
        </td>

        <td>N/A</td>

        <td>No</td>
      </tr>

      <tr>
        <td><code>Protocols</code></td>

        <td>
          Supported protocols for outbound TLS/SSL. If no protocols are specified, then all
          protocols available for the JVM will be permitted.

          <p>To restrict protocols, add the following elements listing the supported protocols:</p>
          <pre class="prettyprint">
&lt;Protocols&gt;
 &lt;Protocol&gt;TLSv1&lt;/Protocol&gt;
 &lt;Protocol&gt;TLSv1.2&lt;/Protocol&gt;
 &lt;Protocol&gt;SSLv2Hello&lt;/Protocol&gt; 
&lt;/Protocols&gt;
</pre>
        </td>

        <td>N/A</td>

        <td>No</td>
      </tr>
    </tbody>
  </table>

  <h3 id=
  "tlsssltargetendpointconfiguration-sampletargetendpointwithoutboundclientauthenticationenabled">
  Sample TargetEndpoint with outbound client authentication enabled</h3>

  <div id="well">
    <pre class="prettyprint">
&lt;TargetEndpoint name="default"&gt;
  &lt;HttpTargetConnection&gt;
        &lt;URL&gt;https://myservice.com&lt;/URL&gt;
    &lt;SSLInfo&gt;
      &lt;Enabled&gt;true&lt;/Enabled&gt;
      &lt;ClientAuthEnabled&gt;true&lt;/ClientAuthEnabled&gt;
      &lt;KeyStore&gt;myKeystore&lt;/KeyStore&gt;
      &lt;KeyAlias&gt;myKey&lt;/KeyAlias&gt;
      &lt;TrustStore&gt;myTruststore&lt;/TrustStore&gt;
    &lt;/SSLInfo&gt;
  &lt;/HttpTargetConnection&gt;
&lt;/TargetEndpoint&gt;
</pre>
  </div>

  <p>For detailed instructions, see <a href=
  "/api-platform/system-administration/configuring-ssl-edge-backend-service.html">Configuring TLS
  from Edge to the backend (Cloud and Private Cloud)</a>.</p>

  <h3 id="tlsssltargetendpointconfiguration-usingflowvariablestosettlssslvaluesdynamically">Using
  flow variables to set TLS/SSL values dynamically</h3>

  <p>You can also dynamically set TLS/SSL details to support flexible runtime requirements.
  For example, if your proxy connects to two potentially different targets (a test target and a
  production target), you can have your API proxy programmatically detect which environment it's
  calling and dynamically set references to the appropriate keystore and truststore. The following
  Apigee Community article explains this scenario in more detail and provides deployable API
  proxy examples: <a href=
  "https://community.apigee.com/articles/21424/dynamic-sslinfo-for-targetendpoint-using-variable.html"
  target=
  "_blank">https://community.apigee.com/articles/21424/dynamic-sslinfo-for-targetendpoint-using-variable.html</a>.</p>

  <p>In the following example of how the <span style=
  "font-family:courier new,courier,monospace;">&lt;SSLInfo&gt;</span> tag would be set in a
  TargetEndpoint configuration, the values can be supplied at runtime, for example, by a Java
  Callout, a JavaScript policy, or an Assign Message policy. Use whichever message variables
  contain the values you want to set.</p>

  <p>Variables are allowed in only the following elements.</p>
<aside class="note">These elements support the dynamic string substitution feature called
  <a href="/api-platform/reference/message-template-intro.html">message templating</a>.</aside>
  <pre class="prettyprint">
&lt;SSLInfo&gt;
    &lt;Enabled&gt;{myvars.ssl.enabled}&lt;/Enabled&gt;
    &lt;ClientAuthEnabled&gt;{myvars.ssl.client.auth.enabled}&lt;/ClientAuthEnabled&gt;
    &lt;KeyStore&gt;{myvars.ssl.keystore}&lt;/KeyStore&gt;
    &lt;KeyAlias&gt;{myvars.ssl.keyAlias}&lt;/KeyAlias&gt;
    &lt;TrustStore&gt;{myvars.ssl.trustStore}&lt;/TrustStore&gt;
&lt;/SSLInfo&gt;
</pre>

  <aside class="note"><b>Note:</b> Variable replacement of TLS/SSL values can only be used for
  a TargetEndpoint. Any attempt to use variables in any other context, such as virtual host
  configuration or message logging, will cause validation failures.</aside>

  <h3 id="tlsssltargetendpointconfiguration-usingreferencestosettlssslvaluesdynamically">Using
  references to set TLS/SSL values dynamically</h3>

  <p>When configuring a TargetEndpoint that uses HTTPS, you have to consider the case when the
  TLS/SSL cert expires, or a change to the system configuration requires you to update the cert. In
  an Edge for Private Cloud installation, when configuring TLS/SSL by using static values or by
  using flow variables, there is a chance that you will have to restart the Message Processors.
   </p>

  <p>For more, see <a href=
  "/api-platform/system-administration/update-or-replace-ssl-certificate.html">Update a TLS
  certificate</a>.</p>

  <p>However, you can optionally configure the TargetEndpoint to use a <em>reference</em> to the
  keystore or truststore instead. The advantage to using a reference is that you can update the
  reference to point to a different keystore or truststore to update the TLS/SSL cert without
  having to restart Message Processors.    </p>

  <aside class="note"><b>Note:</b> You can only use a reference to the keystore and truststore; you
  cannot use a reference to the alias. When you change the reference to a keystore, ensure that the
  alias name of the cert is the same as in the old keystore.</aside>

  <p>For example, shown below is a TargetEndpoint that uses a reference to the keystore:</p>
  <pre class="prettyprint">
<strong>&lt;SSLInfo&gt; 
    &lt;Enabled&gt;true&lt;/Enabled&gt; 
    &lt;ClientAuthEnabled&gt;false&lt;/ClientAuthEnabled&gt; 
    &lt;KeyStore&gt;ref://keystoreref&lt;/KeyStore&gt; 
    &lt;KeyAlias&gt;myKeyAlias&lt;/KeyAlias&gt; 
&lt;/SSLInfo&gt;</strong>
</pre>

  <p>Use the following POST API call to create the reference named
  <strong>keystoreref</strong>:</p>
  <pre class="prettyprint">
curl -X POST  -H "Content-Type:application/xml" https://api.enterprise.apigee.com/v1/o/{org_name}/e/{env_name}/references \
-d '&lt;ResourceReference name="<strong>keystoreref</strong>"&gt;
    &lt;Refers&gt;<strong>myTestKeystore</strong>&lt;/Refers&gt;
    &lt;ResourceType&gt;KeyStore&lt;/ResourceType&gt;
&lt;/ResourceReference&gt;' -u email:password
</pre>

  <p>The reference specifies the name of the keystore and its type.</p>

  <p>Use the following GET API call to view the reference:</p>
  <pre class="prettyprint">
curl -X GET https://api.enterprise.apigee.com/v1/o/[org_name}/e/{env_name}/references/keystoreref -u uname:password
</pre>

  <p>To later change the reference to point to a different keystore, ensuring that the alias has
  the same name, use the following PUT call:</p>
  <pre class="prettyprint">
curl -X PUT -H "Content-Type:application/xml" https://api.enterprise.apigee.com/v1/o/{org_name}/e/{env_name}/references/<strong>keystoreref</strong> \
-d '&lt;ResourceReference name="<strong>keystoreref</strong>"&gt;
    &lt;Refers&gt;<strong>myNewKeystore</strong>&lt;/Refers&gt;
    &lt;ResourceType&gt;KeyStore&lt;/ResourceType&gt;
&lt;/ResourceReference&gt;' -u email:password
</pre>

  <h3 id="tlsssltargetendpointconfiguration-targetendpointwithtargetloadbalancing">TargetEndpoint
  with target load balancing</h3>

  <p>TargetEndpoints support load balancing across multiple named TargetServers using three load
  balancing algorithms.</p>

  <p>For detailed instructions, refer to <a href=
  "/api-platform/deploy/load-balancing-across-backend-servers.html">Load balancing across backend
  servers</a>.</p>

  <h2 id="policies"><a name="policies" id="policies"></a>Policies</h2>

  <p>The <code>/policies</code> directory in an API proxy contains all policies available to be
  attached to Flows in the API proxy.</p>

  <h3 id="policies-policyconfigurationelements">Policy Configuration Elements</h3>

  <table>
    <thead>
      <tr>
        <th>Name</th>

        <th>Description</th>

        <th>Default</th>

        <th>Required?</th>
      </tr>
    </thead>

    <tbody>
      <tr>
        <td><b><code>Policy</code></b></td>

        <td colspan="3"> </td>
      </tr>

      <tr>
        <td><code>name</code></td>

        <td>
          <p>The internal name of the policy. Characters you can use in the name are restricted
          to: <code>A-Z0-9._\-$ %</code>. However, the Edge management UI enforces additional
          restrictions, such as automatically removing characters that are not alphanumeric.</p>

          <p>Optionally, use the <code>&lt;DisplayName&gt;</code> element to label the
          policy in the management UI proxy editor with a different, natural-language name.</p>
        </td>

        <td>N/A</td>

        <td>Yes</td>
      </tr>

      <tr>
        <td><code>enabled</code></td>

        <td>
          <p>Set to <code>true</code> to enforce the policy.</p>

          <p>Set to <code>false</code> to "turn off" the policy. The policy will not be
          enforced even if it remains attached to a flow.</p>
        </td>

        <td>true</td>

        <td>No</td>
      </tr>

      <tr>
        <td><code>continueOnError</code></td>

        <td>
          <p>Set to <code>false</code> to return an error when a policy fails. This is
          expected behavior for most policies.</p>

          <p>Set to <code>true</code> to have flow execution continue even after a policy
          fails.</p>
        </td>

        <td>false</td>

        <td>No</td>
      </tr>

      <tr>
        <td><code>async</code></td>

        <td>
          <p><strong>Note</strong>: This attribute does not make the policy execute asynchronously.
          In most cases, leave this with the default of <code>false</code>.</p>

          <p>When set to <code>true</code>, policy execution is offloaded to a different
          thread, leaving the main thread free to handle additional requests. When the offline
          processing is complete, the main thread comes back and finishes handling the message
          flow. In some cases, setting async to <code>true</code> improves API proxy
          performance. However, overusing async can hurt performance with too much thread
          switching.</p>

          <p>To use asynchronous behavior in API proxies, see <a href=
          "/api-platform/reference/javascript-object-model.html">JavaScript object model</a>.</p>
        </td>

        <td>false</td>

        <td>No</td>
      </tr>
    </tbody>
  </table>

  <h3 id="policies-policyattachment">Policy Attachment</h3>

  <p><img alt="" src="/api-platform/images/proxy_flow_diagram_steps2.png"></p>

  <p>As shown above, API proxy flows execute in the following sequence:</p>

  <p>Policies are attached as processing steps to <i>Flows</i>. The policy's name is used to
  reference the policy to be enforced as a processing Step. The format of a policy attachment is
  the following:</p>
  <pre class="prettyprint">
&lt;Step&gt;&lt;Name&gt;MyPolicy&lt;/Name&gt;&lt;/Step&gt;
</pre>

  <p>Policies are enforced in the order in which they are attached to a Flow. For example:</p>
  <pre class="prettyprint">
&lt;Step&gt;&lt;Name&gt;FirstPolicy&lt;/Name&gt;&lt;/Step&gt;
&lt;Step&gt;&lt;Name&gt;SecondPolicy&lt;/Name&gt;&lt;/Step&gt;
</pre>

  <h3 id="policies-policyattachmentconfigurationelements">Policy Attachment Configuration
  Elements</h3>

  <table>
    <thead>
      <tr>
        <th>Name</th>

        <th>Description</th>

        <th>Default</th>

        <th>Required?</th>
      </tr>
    </thead>

    <tbody>
      <tr>
        <td><b><code>Step</code></b></td>

        <td colspan="3"> </td>
      </tr>

      <tr>
        <td><code>Name</code></td>

        <td>The name of the policy to be executed by this Step definition.</td>

        <td>N/A</td>

        <td>Yes</td>
      </tr>

      <tr>
        <td><code>Condition</code></td>

        <td>A conditional statement that determines whether the policy is enforced or not. If a
        policy has an associated condition, then the policy only executes if the conditional
        statement evaluates to true.</td>

        <td>N/A</td>

        <td>No</td>
      </tr>
    </tbody>
  </table>

  <h2 id="flows"><a name="flows" id="flows"></a>Flows</h2>

  <p>ProxyEndpoint and TargetEndpoint define a pipeline for request and response message
  processing. A processing pipeline consists of a request flow and a response flow. Each request
  flow and response flow is subdivided into a PreFlow, one or more optional 'conditional' or
  'named' Flow, and a PostFlow.</p>

  <ul>
    <li>PreFlow: Always executes. Executes before any conditional Flows.</li>

    <li>PostFlow: Always executes. Executes after any conditional Flows.</li>
  </ul>

  <p>Additionally, you can add a PostClientFlow to the ProxyEndpoint, which executes after the
  response is returned to the requesting client app. Only MessageLogging policies can be attached
  to this flow. PostClientFlow reduces API proxy latency and makes information available for
  logging that is not calculated until after the response is returned to the client, such as the
  <code>client.send.start.time</code> and <code>client.send.end.time</code>.The flow is used
  primarily for measuring the time interval between the start and end timestamps for the response
  message.</p>

  <h2 id="watchaquickhowtovideo">Watch a quick how-to video </h2>

  <div class="video">
    <p><strong>Video:</strong> Check out this short video on using a Message Logging in the
    PostClientFlow.</p>

    <div style="text-align: left; margin:15px">
      <iframe allowfullscreen="" frameborder="0" height="480" src=
      "https://www.youtube.com/embed/R2HO3XsC9ZU?list=PLIXjuPlujxxxe3iTmLtgfIBgpMo7iD7fk" width=
      "854"></iframe>
    </div>
  </div>

  <p>Here's an example of a PostClientFlow with a message logging policy attached.</p>
  <pre class="prettyprint">
    ...
    &lt;PostFlow name="PostFlow"&gt;
        &lt;Request/&gt;
        &lt;Response/&gt;
    &lt;/PostFlow&gt;
    <strong>&lt;PostClientFlow&gt;
        &lt;Request/&gt;
        &lt;Response&gt;
            &lt;Step&gt;
                &lt;Name&gt;Message-Logging-1&lt;/Name&gt;
            &lt;/Step&gt;
        &lt;/Response&gt;
    &lt;/PostClientFlow&gt;</strong>
    ...
</pre>

  <p>The API proxy processing pipeline executes Flows in the following sequence:</p>

  <p>Request Pipeline:</p>

  <ol>
    <li>Proxy Request PreFlow</li>

    <li>Proxy Request Conditional Flows (Optional)</li>

    <li>Proxy Request PostFlow</li>

    <li>Target Request PreFlow</li>

    <li>Target Request Conditional Flows (Optional)</li>

    <li>Target Request PostFlow</li>
  </ol>

  <p>Response Pipeline:</p>

  <ol>
    <li>Target Response PreFlow</li>

    <li>Target Response Conditional Flows (Optional)</li>

    <li>Target Response PostFlow</li>

    <li>Proxy Response PreFlow</li>

    <li>Proxy Response Conditional Flows (Optional)</li>

    <li>Proxy Response PostFlow</li>

    <li>PostClientFlow Response (Optional)</li>
  </ol>

  <p>Only those Flows with policy attachments need to be configured in ProxyEndpoint or
  TargetEndpoint configurations. PreFlow and PostFlow need only be specified in a ProxyEndpoint or
  TargetEndpoint configuration when a policy needs to be enforced during PreFlow or PostFlow
  processing.</p>

  <p>In contrast to conditional flows, the ordering of PreFlow and PostFlow elements is not
  important--the API proxy will always execute each at the appropriate point in the pipeline,
  regardless of where they appear in the Endpoint configuration.</p>

  <h3 id="watchaquickhowtovideo-conditionalflows">Conditional Flows</h3>

  <p>ProxyEndpoints and TargetEndpoints support an unlimited number of conditional flows (also
  known as 'named flows').</p>

  <p>The API proxy tests for the condition specified in the conditional flow and, if the condition
  is met, the processing steps in the conditional flow are executed by the API proxy. If the
  condition is not met, then the processing steps in the conditional flow are bypassed. Conditional
  flows are evaluated in the order defined in the API proxy and the first one whose condition is
  met is executed.  </p>

  <p>By defining conditional flows, you gain the ability to apply processing steps in an API proxy
  based on:</p>

  <ul>
    <li>Request URI</li>

    <li>HTTP verb (GET/PUT/POST/DELETE)</li>

    <li>Value of a query param, header, and form param</li>

    <li>Many other types of conditions </li>
  </ul>

  <p>For example, the following conditional flow specifies that it is executed only when the
  request resource path is <code>/accesstoken</code>. Any inbound request with the
  path <code>/accesstoken</code> causes this flow to be executed, along with any policies
  that are attached to the flow. If the request path does not include the suffix
  <code>/accesstoken</code>, then the flow does not execute (although another conditional flow
  might).</p>
  <pre class="prettyprint">
&lt;Flows&gt;
  &lt;Flow name="TokenEndpoint"&gt;
    &lt;Condition&gt;proxy.pathsuffix MatchesPath "/accesstoken"&lt;/Condition&gt;
    &lt;Request&gt;
      &lt;Step&gt;
        &lt;Name&gt;GenerateAccessToken&lt;/Name&gt;
      &lt;/Step&gt;
    &lt;/Request&gt; 
  &lt;/Flow&gt;
&lt;/Flows&gt;   
</pre>

  <h3 id="watchaquickhowtovideo-flowconfigurationelements">Flow Configuration Elements</h3>

  <table>
    <thead>
      <tr>
        <th>Name</th>

        <th>Description</th>

        <th>Default</th>

        <th>Required?</th>
      </tr>
    </thead>

    <tbody>
      <tr>
        <td><b><code>Flow</code></b></td>

        <td colspan="3">A request or response processing pipeline defined by A ProxyEndpoint or
        TargetEndpoint</td>
      </tr>

      <tr>
        <td><code>Name</code></td>

        <td>The unique name of the Flow.</td>

        <td>N/A</td>

        <td>Yes</td>
      </tr>

      <tr>
        <td><code>Condition</code></td>

        <td>A conditional statement that evaluates on or more variables to evaluate to true or
        false. All Flows other than the predefined PreFlow and PostFlow types must define a
        condition for their execution.</td>

        <td>N/A</td>

        <td>Yes</td>
      </tr>

      <tr>
        <td><code>Request</code></td>

        <td>The pipeline associated with Request message processing</td>

        <td>N/A</td>

        <td>No</td>
      </tr>

      <tr>
        <td><code>Response</code></td>

        <td>The pipeline associated with Response message processing</td>

        <td>N/A</td>

        <td>No</td>
      </tr>
    </tbody>
  </table>

  <h3 id="watchaquickhowtovideo-stepprocessing">Step processing</h3>

  <p>The sequential ordering of conditional Flows is enforced by Apigee Edge. Conditional Flows
  execute from top to bottom. The first conditional Flow whose condition evaluates to
  <code>true</code> is executed, and only one conditional Flow is executed.</p>

  <p>For example, in the following Flow configuration, any inbound request that does not include
  the path suffix <code>/first</code> or <code>/second</code> will cause the <code>ThirdFlow</code>
  to execute, enforcing the policy called <code>Return404</code>.</p>

  <div id="well">
    <pre class="prettyprint">
&lt;Flows&gt;
  &lt;Flow name="FirstFlow"&gt;
    &lt;Condition&gt;proxy.pathsuffix MatchesPath "/first"&lt;/Condition&gt;
    &lt;Request&gt;
      &lt;Step&gt;&lt;Name&gt;FirstPolicy&lt;/Name&gt;&lt;/Step&gt;
    &lt;/Request&gt;
  &lt;/Flow&gt;
  &lt;Flow name="SecondFlow"&gt;
    &lt;Condition&gt;proxy.pathsuffix MatchesPath "/second"&lt;/Condition&gt;
    &lt;Request&gt;
      &lt;Step&gt;&lt;Name&gt;FirstPolicy&lt;/Name&gt;&lt;/Step&gt;
      &lt;Step&gt;&lt;Name&gt;SecondPolicy&lt;/Name&gt;&lt;/Step&gt;
    &lt;/Request&gt;
  &lt;/Flow&gt;
  &lt;Flow name="ThirdFlow"&gt;
    &lt;Request&gt;
      &lt;Step&gt;&lt;Name&gt;Return404&lt;/Name&gt;&lt;/Step&gt;
    &lt;/Request&gt;
  &lt;/Flow&gt;
&lt;/Flows&gt;
</pre>
  </div>

  <h2 id="resources"><a name="resources" id="resources"></a>Resources</h2>

  <p>"Resources" (resource files for use in API proxies) are scripts, code, and XSL transformations
  that can be attached to Flows using policies. These appear in the "Scripts" section of the API
  proxy editor in the management UI.</p>

  <p>See <a href="/api-platform/develop/resource-files.html">Resource files</a> for the supported
  resource types.</p>

  <p>Resources can be stored in an API proxy, an environment, or an organization. In each case, a
  resource is referenced by name in a Policy. API Services resolves the name by moving from the API
  proxy, to environment, to organization level.</p>

  <p>A resource stored at the organization level can be referenced by Policies in any environment.
  A resource stored at the environment level can be referenced by Policies in that environment. A
  resource stored at the API proxy level can be referenced only by Policies in that API proxy.</p>

  <p>Post questions to the <a href=
  "https://community.apigee.com/content/apigee-customer-support">Apigee Developer Forum</a>.</p>{% endblock %}
