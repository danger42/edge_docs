  {% extends "_base.html" %} {% block title %}JWT policies overview{% endblock %} {% block body %}

  <p id="about-jwt-and-the-jwt-policies">This topic provides general information about JWT and the
  Apigee JWT policies that may be of interest to Apigee proxy developers.</p>

  <h2 id="introduction">Introduction</h2>

  <p>JSON Web Tokens, or JWT, are commonly used to share claims or assertions between connected
  applications. The JWT policies enables Edge API proxies to:</p>

  <ul>
    <li><a href=
    "/api-platform/reference/policies/generate-jwt-policy.html"><strong>Generate</strong></a>
    signed JWTs.</li>

    <li><a href=
    "/api-platform/reference/policies/verify-jwt-policy.html"><strong>Verify</strong></a>
    digitally-signed JWTs and claims within those JWTs.</li>

    <li><a href=
    "/api-platform/reference/policies/decode-jwt-policy.html"><strong>Decode</strong></a> signed
    JWTs without validating signatures on the token.</li>
  </ul>

  <p>In the latter two cases, the policy also sets variables that allow additional policies, or the
  backend services themselves, to inspect the validated claims and to take decisions based on those
  claims.</p>

  <p>When using the Verify JWT policy, an invalid JWT will be rejected and will result in an error
  condition. Similarly, when using the Decode JWT policy, a malformed JWT will result in an error
  condition.</p>

  <h2 id="use-cases">Use cases</h2>

  <p>You can use the policy to:</p>

  <ul>
    <li>Verify and extract claims from a JWT obtained from inbound client requests, from target
    service responses, from Service Callout policy responses, or from other sources. Edge will
    verify the signature on a JWT, whether the JWT was generated by a third-party, or by Edge
    itself, using either RSA or HMAC algorithms.</li>

    <li>Generate a new JWT on either the proxy or target endpoint sides of an Edge proxy. For
    example, you might create a proxy request flow that generates a JWT and returns it to a client.
    Or, you might design a proxy so that it generates a JWT on the target request flow, and
    attaches it to the request sent to the target. Those claims would then be available to enable
    backend services to apply further security processing.</li>

    <li>Decode a JWT. Decoding is most useful when used in concert with the Verify JWT Policy, when
    the value of a claim from within the JWT must be known before verifying the signature of the
    JWT.</li>
  </ul>

  <h2 id="about-standard-and-custom-claims">About standard and additional claims</h2>

  <p>Edge supports a set of standard (registered) JWT claims including subject, issuer, audience,
  expiration time, and not-before time. You can read about these claims in the <a href=
  "https://tools.ietf.org/html/rfc7519#section-4.1">Registered Claim Names</a> section of the JWT
  specification. In addition, Edge supports adding additional claims to a JWT. Each claim is a
  simple name/value pair, where the value can be of type number, boolean, string, map, or array of
  any of the primitives. In JWT, the set of claims, registered and additional, are represented as a
  simple JSON hash, then canonicalized and signed using a symmetric or asymmetric cryptographic
  signing algorithm.</p>

  <h2 id="about-signature-encryption-algorithms">About signature encryption algorithms</h2>

  <p>The JWT Verification and JWT Generation policies support RSA and HMAC algorithms, using SHA2
  checksums of bit strength 256, 384, or 512. The JWT Decode policy works regardless of the
  algorithm that was used to sign the JWT.</p>

  <h2 id="hmac-algorithm">HMAC algorithm</h2>

  <p>The HMAC algorithm relies on a shared secret, known as the secret key, for creating the
  signature (also known as signing the JWT) and for verifying the signature.</p>

  <h3 id="rsa-algorithm">RSA algorithm</h3>

  <p>The RSA algorithm uses a public/private key pair for the cryptographic signature. With RSA
  signatures, the signing party uses a private key to sign the JWT, and the verifying party uses
  the matching public key to verify the signature on the JWT.</p>

  <h2 id="parts-of-a-jwt">Parts of a JWT</h2>

  <p>A signed JWT encodes information in three parts: the header, the payload, and the
  signature.</p>

  <ul>
    <li>The Generate JWT policy creates all of those parts.</li>

    <li>The Verify JWT policy examines all three parts.</li>

    <li>The Decode JWT policy examines the header and payload.</li>
  </ul>

  <p>To learn more about the parts of a JWT and how they are encoded and signed, refer to <a href=
  "https://tools.ietf.org/html/rfc7519">IETF RFC7519</a>.</p>

  <h2 id="usingajsonwebkeysetjwkstoverifyajwt">Using a JSON Web Key Set (JWKS) to verify a JWT</h2>

  <p>When you verify a JWT signed with an RSA algorithm, you need to provide the public key that is
  associated with the private key used to sign the token. You have <strong>two options</strong> for
  providing the public key to the Verify JWT policy:</p>

  <ul>
    <li>use the actual public key value (typically provided in a flow variable), or</li>

    <li>use a public key wrapped in a JWKS.</li>
  </ul>

  <h3 id="about-jwks">About JWKS</h3>

  <p>A JWKS is a JSON structure that represents a set of JSON Web Keys (JWKs). A JWK is a JSON data
  structure that represents a cryptographic key. JWK and JWKS are described in <a href=
  "https://tools.ietf.org/html/rfc7517">RFC7517</a>.</p>

  <h3 id="required-jwks-structure">Required JWKS structure</h3>

  <p>Each key element in the JWKS must include these attributes:</p>

  <ul>
    <li><strong>kty</strong> - Must be set to RSA.</li>

    <li><strong>kid</strong> (the key id) - Can be any arbitrary value (no duplicates within a key
    set). If the inbound JWT bears a key ID which is present in the set of JWKS, then the policy
    will use the correct public key to verify the JWT signature.</li>

    <li><strong>n</strong> - The RSA key value "modulus".</li>

    <li><strong>e</strong> - The RSA key value "exponent".</li>
  </ul>

  <p>Following are optional elements and their required values:</p>

  <ul>
    <li><strong>alg</strong> - If present, must be RS256.</li>

    <li><strong>use</strong> - If present, must be sig.</li>
  </ul>

  <p>The following JWKS includes the required elements and values and would be valid on Edge (from
  https://<a href=
  "https://www.googleapis.com/oauth2/v3/certs">www.googleapis.com/oauth2/v3/certs</a>):</p>
  <pre class="prettyprint">
{  
   "keys":[  
      {  
         "kty":"RSA",
         "alg":"RS256",
         "use":"sig",
         "kid":"ca04df587b5a7cead80abee9ea8dcf7586a78e01",
         "n":"iXn-WmrwLLBa-QDiToBozpu4Y4ThKdwORWFXQa9I75pKOvPUjUjE2Bk05TUSt7-V7KDjCq0_Nkd-X9rMRV5LKgCa0_F8YgI30QS3bUm9orFryrdOc65PUIVFVxIwMZuGDY1hj6HEJVWIr0CZdcgNIll06BasclckkUK4O-Eh7MaQrqb646ghFlG3zlgk9b2duHbDOq3s39ICPinRQWC6NqTYfqg7E8GN_NLY9srUCc_MswuUfMJ2cKT6edrhLuIwIj_74YGkpOwilr2VswKsvJ7dcoiJxheKYvKDKtZFkbKrWETTJSGX2Xeh0DFB0lqbKLVvqkM2lFU2Qx1OgtTnrw",
         "e":"AQAB"
      },
      {  
         "kty":"RSA",
         "alg":"RS256",
         "use":"sig",
         "kid":"91412840c1019dedff1854b89938ad0a9078b871",
         "n":"veQQDTKL8UKIRIuWxHLeRH0umTHtnm2LXej56MungXuFZwmk_xccvsMpCtXmqhvEmHyAmKF06YRRWAomHIwC7IBz9BsIjPYtOkvVkff_SCFoyuyDFkNsDsbTydIDUFAV5YlhZOvgq1PJCzu8AfU9HoRf0WIEnexpTDyWzlqNbg0b94Tlmw01C5kDRGDD33v8i-RM4xXXyovBA_8R8D9t0aIzC9iVL418E0FOXAQ5xvrbvTXAkr17U4yIINUZ03q7i5tOxSA1z0s_-CK6NNoLZcDQXddBFCCYXNmfhaiu-NeSVePZMmDZGIFZIhIvagPcs3pZfSC5ysyo3tu3r16tdw",
         "e":"AQAB"
      },
      {  
         "kty":"RSA",
         "alg":"RS256",
         "use":"sig",
         "kid":"f5010d8a5353b010c81fa45f1e43d2789b18bc9c",
         "n":"2_jAH07j0ufDhv3sE2ky4m7w7xWbOZfMa1EI3MAOMdAcskKGDlv67sN8OKTo3B8uDLIx8F8lfGToG4hUr8N08YYXFzqRpXk3b8_kzVDrF1Z7dSi_OhQXkXsnEdUPAn3CQu6a_ObQ7XAyrr2eF0L_unptoQhanYte78LwOrPGKZTEKN6MEwHxz1yTR37yl88VNoV3WsLoeuDxhomgtSD5liFGBFuJt5-f5x-ZwXdDKgNgdIA7k8YYw246o47OKrb9xGR62qi0Mahxot_523BLyY18CUgbpb-VBPpVyseNOrpUQarEFcAi3Pab4vwAzZoA8NVyvl7aF2QRdIMIXoDmPw",
         "e":"AQAB"
      }
   ]
}
</pre>

  <h3 id="usingajsonwebkeysetjwkstoverifyajwt-designingyourproxytousejwks">Designing your proxy to
  use JWKS</h3>

  <p>When a JWT is obtained from an issuer, often the issuer inserts a Key ID (or kid) into the JWT
  header. The key tells the recipient of the JWT how to find the public or secret key necessary to
  verify the signature on the signed JWT.</p>

  <p>As an example, suppose an issuer signs a JWT with a private key. The "Key ID" identifies the
  matching public key to use to verify the JWT. The list of public keys is typically available at
  some well-known endpoint, for example: <a href=
  "https://www.googleapis.com/oauth2/v3/certs">https://www.googleapis.com/oauth2/v3/certs</a>.</p>

  <p>This is the basic sequence that Edge (or any platform that works with JWKS) needs to perform
  to work with a JWT that has a JWKS:</p>

  <ol>
    <li>Examine the JWT header to find the Key ID (kid).</li>

    <li>Retrieve the list of keys and IDs from the well-known endpoint for a given issuer.</li>

    <li>Extract the public key from the list of keys with the key ID noted in the JWT header.</li>

    <li>Use that public key to verify the signature on the JWT.<br>
      <br>

      <aside class="note"><b>Note:</b> The Verify JWT policy performs the lookup of key-for-keyid
      automatically.</aside>
    </li>
  </ol>

  <p>As an Edge API proxy developer you need to do the following to perform JWT verification:</p>

  <ol>
    <li>Retrieve the list of keys and IDs from the well-known endpoint for a given issuer. You can
    use a Service Callout policy for this step.
    Note: It's a good practice to cache the JWKS to avoid a Service Callout on every request. 
    </li>

    <li>In the Verify JWT policy, specify the location of the JWT (in the <a href=
    "/api-platform/reference/policies/verify-jwt-policy.html#source">Source element</a>) and the
    JWKS payload (in the <a href=
    "/api-platform/reference/policies/verify-jwt-policy.html#publickeyjwks">PublicKey/JWKS
    element</a>). For example:
      <pre class="prettyprint">
&lt;VerifyJWT name="JWT-Verify-RS256"&gt;
    &lt;Algorithm&gt;RS256&lt;/Algorithm&gt;
    &lt;Source&gt;json.jwt&lt;/Source&gt;
    &lt;IgnoreUnresolvedVariables&gt;false&lt;/IgnoreUnresolvedVariables&gt;
    &lt;PublicKey&gt;
        &lt;JWKS ref="public.jwks"/&gt;
    &lt;/PublicKey&gt;
    &lt;Subject&gt;apigee-seattle-hatrack-montage&lt;/Subject&gt;
    &lt;Issuer&gt;urn://apigee-edge-JWT-policy-test&lt;/Issuer&gt;
    &lt;Audience&gt;urn://c60511c0-12a2-473c-80fd-42528eb65a6a&lt;/Audience&gt;
    &lt;AdditionalClaims&gt;
        &lt;Claim name="show"&gt;And now for something completely different.&lt;/Claim&gt;    
    &lt;/AdditionalClaims&gt;
&lt;/VerifyJWT&gt;
</pre>
    </li>
  </ol>

  <p>The Verify JWT policy does everything else:</p>

  <ul>
    <li>If a key with a Key ID that matches the Key ID (kid) asserted in the JWT is not found in
    the JWKS, then the Verify JWT policy throws an error and does not validate the JWT.</li>

    <li>If the inbound JWT does not bear a key ID (kid) in the header, then this mapping of
    keyid-to-verification-key is not possible.</li>
  </ul>

  <p>As the proxy designer, you are responsible for determining the key to use; in some cases this
  may be a fixed, hard-coded key.</p>

  <h2 id="seealso">See also</h2>

  <ul>
    <li><a href="/api-platform/reference/policies/generate-jwt-policy.html">Generate JWT policy</a></li>

    <li><a href="/api-platform/reference/policies/verify-jwt-policy.html">Verify JWT policy</a></li>

    <li><a href="/api-platform/reference/policies/decode-jwt-policy.html">Decode JWT policy</a></li>
  </ul>

  {% endblock %}
